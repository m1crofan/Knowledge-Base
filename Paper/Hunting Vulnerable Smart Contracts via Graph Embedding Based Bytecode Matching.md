### 摘要

> 智能合约漏洞因其造成的经济损失而引起了广泛关注。将已知漏洞推断为未知漏洞的基于匹配的检测方法已被证明在其他平台上是有效的。然而，直接将该技术应用于智能合约会受到两个问题的阻碍，即**编译器**的快速发展导致**字节码生成的多样性以及同质业务逻辑容易造成噪声代码的干扰**。为了解决这些问题，我们提出了面向合约字节码的规范化和切片技术来增强字节码匹配。具体来说，我们进行数据和指令级标准化，以统一不同编译器生成的字节码，并通过模拟字节码执行跟踪数据和控制流来强制执行**特定于合约的切片**，以尽可能**修剪噪声代码**。基于上述技术，我们设计了一种**无监督图嵌入算法**，将代码图编码为定量可比的向量。可以通过测量其向量与已知易受攻击的智能合约之间的相似性来识别潜在易受攻击的智能合约。我们的评估显示了效率（平均每个合约 0.47 秒）、有效性（160 个已验证的真阳性）和高精度（排名第一的为 91.95%）。值得注意的是，我们还识别了数十个蜜罐合约，进一步证明了我们方法的能力。智能合约漏洞因其造成的经济损失而引起了广泛关注。将已知漏洞推断为未知漏洞的基于匹配的检测方法已被证明在其他平台上是有效的。然而，直接将该技术应用于智能合约会受到两个问题的阻碍，即编译器的快速发展导致**字节码生成的多样性以及同质业务逻辑容易造成噪声代码的干扰**。为了解决这些问题，我们提出了面向合约字节码的规范化和切片技术来增强字节码匹配。具体来说，我们进行数据和指令级标准化，以统一不同编译器生成的字节码，并通过模拟字节码执行跟踪数据和控制流来强制执行**特定于合约的切片**，以尽可能**修剪噪声代码**。基于上述技术，我们设计了一种**无监督图嵌入算法**，将代码图编码为定量可比的向量。可以通过测量其向量与已知易受攻击的智能合约之间的相似性来识别潜在易受攻击的智能合约。我们的评估显示了效率（平均每个合约 0.47 秒）、有效性（160 个已验证的真阳性）和高精度（排名第一的为 91.95%）。值得注意的是，我们还识别了数十个蜜罐合约，进一步证明了我们方法的能力。

### 引言

>
>
>长期以来，随着以太坊的普及，智能合约、在以太坊上运行并主要在 Solidity 中开发的程序引起了很多安全问题。事实上，智能合约漏洞已经造成了巨大的经济损失。例如，DAO [1] 和 BeautyChain [2] 中的漏洞导致了超过 10 亿美元的损失。因此，智能合约的漏洞检测成为近年来的一项重要任务。
>
>![image-20231015112534963](C:/Users/microfan/AppData/Roaming/Typora/typora-user-images/image-20231015112535064.png)
>
>事实证明，基于匹配的方法对于检测漏洞是有效的，例如，在桌面和物联网应用程序中[3]-[7]。此类方法背后的直觉是搜索与已知漏洞类似的实现。不幸的是，将基于匹配的技术应用于智能合约是一项艰巨的任务。有两个问题需要解决。首先，研究表明只有 1% 的智能合约是开源的 [8]，因此实用的基于匹配的检测方法应该与字节码一起工作。然而，Solidity编译器的快速发展导致了数十种编译器版本，即使对于相同的源代码片段，不同版本也可能生成不同的字节码。字节码生成的多样性会阻碍字节码匹配。例如，一个易受攻击的实现可能会被错过，因为它是用不同版本的编译器编译的，因此包含大量不同的指令。我们演示了两个版本的编译器为图 1 中的语句生成的字节码的影响。旧版本为该语句生成 36 条指令，而新版本生成 33 条指令，其中 28 条指令是相同的。我们在图 1 中显示了两个差异片段，其中包含不同的程序计数器和 SWAP1/GT 与 SWAP1/GT 对比。 LT 进行同样的比较操作。使用较新编译器生成的字节码作为查询种子，旧版本编译器生成的字节码作为目标，相同源代码的相似度仅为 77.8%。其次，漏洞通常涉及很少的语句，但易受攻击的智能合约，无论是种子还是目标，通常包含许多与漏洞无关的语句。这些与漏洞无关的语句被称为噪声代码，它们会混淆代码匹配，因此减轻它们的干扰是一个迫切需要解决的任务。以图2为例，其中两个函数受到影响来自同类乘法溢出（以橙色突出显示）。每个函数中只有三行进行计算，防护不足与对应的漏洞有关。**所有其他内容都是无关紧要的**，包括框起来的部分和省略的部分，既不会对溢出逻辑做出贡献，也不会试图确保乘法安全。这种噪声代码的存在会阻止我们有效地将已知存在漏洞的 BecToken 与图 2b 中的 BecToken 进行匹配，从而导致漏掉潜在的漏洞。事实上，字节码匹配相似度仅为 51.7%，并不能自信地将 Beercoin 报告为易受攻击的。除了这种情况之外，我们还必须注意到，在实践中，由于应用场景有限，很多合约都强制执行同构的业务逻辑。它不可避免地会带来很多类似的实现，例如以太币充值/提现、代币转账等。更具体地说，余额检查（例如图 2b 中的第 4 行）和操作（例如加法和减法）、通过调用发送以太币以及一些其他常见操作将频繁发生，并且通常以相同的方式实现。因此，基于匹配的智能合约分析比传统应用程序更容易受到噪声代码的影响。当同质噪声代码主导功能时，与漏洞直接相关的关键操作在代码匹配中将不会受到足够的关注。换句话说，**无漏洞的合约很可能被误检测**。我们将在第 IV-C 节中展示噪声代码可能会导致很多不准确。
>
>为了解决这些问题，我们提出了面向智能合约字节码的规范化和切片技术来增强字节码匹配。具体来说，我们从两个方面进行归一化以统一不同的字节码以进行匹配，即通过用有意义的标签标记数据值来进行数据归一化，以及通过对操作数重新排序并忽略无关紧要的指令来进行指令归一化。此外，为了削弱噪声代码的干扰，我们通过模拟字节码执行并跟踪数据流和控制流来强制执行合约特定的切片，以增强干净代码集上的字节码匹配。
>
>![image-20231015114840601](https://raw.githubusercontent.com/m1crofan/image/main/image-20231015114840601.png)
>
>遵循基于匹配的技术原理，我们可以将种子和目标合约编码为定量和可测量形式的向量。请注意，除了字节码指令之外，结构信息在面向合约的匹配中也起着重要作用。图3中的一个简单例子可以说明结构信息在匹配中的重要性，其中交换两个语句的顺序（图3b）可以修复图3a中的重入漏洞[11]。为了有效地引入结构信息并避免现有研究[5]、[6]中所做的特征工程，我们设计了一种**端到端的图嵌入算法**，将基于切片的控制流图编码为向量并测量向量相似度用于字节码匹配。如果它们的向量与那些已知的易受攻击的合约高度相似，我们就会利用测量结果来报告潜在的易受攻击的合约。
>
>我们实现了一个原型，并在超过 200 万个闭源智能合约和约 32,500 个开源合约上对其进行了评估。结果表明，我们的方法**只需使用一些已知的易受攻击的合约作为种子**，就可以有效地捕获数百个漏洞，并且具有高性能和高精度。我们总共检测到 160 个可利用的漏洞，并在私有区块链环境中使用专门开发的攻击负载一一验证。我们还证明了标准化和切片的必要性以及考虑结构信息的有效性。我们的比较分析表明，我们的方法通常优于最先进的检测器。
>
>还值得注意的是，我们在审计的早期阶段识别了 23 个蜜罐合约 [12]，因为这些蜜罐被伪装成容易受到攻击的攻击者。以未发现的蜜罐合约为种子，通过相同的匹配方法，我们进一步发现了其他 33 个蜜罐。它们的危害性也经过人工验证。
>
>贡献点
>
>- 据我们所知，我们是第一个在智能合约字节码匹配中引入图嵌入方法来发现未知漏洞的人。我们提出标准化和切片来解决两个合约的具体问题。
>
>- 我们实现一个原型并在现实世界的合同中对其进行评估。实验表明其可扩展性（每个合约 0.47 秒）、高精度（91.95%）我们实现一个原型并在现实世界的合同中对其进行评估。实验表明其可扩展性（每个合约 0.47 秒）、高精度（91.95%）排名第一）和有效性（160 个真阳性，比较分析的准确性更高）。
>
>- 我们还使用该方法成功检测了数十个蜜罐合约，进一步说明了我们方法的能力。
>
>- 长期以来，随着以太坊的普及，智能合约、在以太坊上运行并主要在 Solidity 中开发的程序引起了很多安全问题。事实上，智能合约漏洞已经造成了巨大的经济损失。例如，DAO [1] 和 BeautyChain [2] 中的漏洞导致了超过 10 亿美元的损失。因此，智能合约的漏洞检测成为近年来的一项重要任务。
>
>  ![image-20231015112534963](C:/Users/microfan/AppData/Roaming/Typora/typora-user-images/image-20231015112535064.png)
>
>  事实证明，基于匹配的方法对于检测漏洞是有效的，例如，在桌面和物联网应用程序中[3]-[7]。此类方法背后的直觉是搜索与已知漏洞类似的实现。不幸的是，将基于匹配的技术应用于智能合约是一项艰巨的任务。有两个问题需要解决。首先，研究表明只有 1% 的智能合约是开源的 [8]，因此实用的基于匹配的检测方法应该与字节码一起工作。然而，Solidity编译器的快速发展导致了数十种编译器版本，即使对于相同的源代码片段，不同版本也可能生成不同的字节码。字节码生成的多样性会阻碍字节码匹配。例如，一个易受攻击的实现可能会被错过，因为它是用不同版本的编译器编译的，因此包含大量不同的指令。我们演示了两个版本的编译器为图 1 中的语句生成的字节码的影响。旧版本为该语句生成 36 条指令，而新版本生成 33 条指令，其中 28 条指令是相同的。我们在图 1 中显示了两个差异片段，其中包含不同的程序计数器和 SWAP1/GT 与 SWAP1/GT 对比。 LT 进行同样的比较操作。使用较新编译器生成的字节码作为查询种子，旧版本编译器生成的字节码作为目标，相同源代码的相似度仅为 77.8%。其次，漏洞通常涉及很少的语句，但易受攻击的智能合约，无论是种子还是目标，通常包含许多与漏洞无关的语句。这些与漏洞无关的语句被称为噪声代码，它们会混淆代码匹配，因此减轻它们的干扰是一个迫切需要解决的任务。以图2为例，其中两个函数受到影响来自同类乘法溢出（以橙色突出显示）。每个函数中只有三行进行计算，防护不足与对应的漏洞有关。**所有其他内容都是无关紧要的**，包括框起来的部分和省略的部分，既不会对溢出逻辑做出贡献，也不会试图确保乘法安全。这种噪声代码的存在会阻止我们有效地将已知存在漏洞的 BecToken 与图 2b 中的 BecToken 进行匹配，从而导致漏掉潜在的漏洞。事实上，字节码匹配相似度仅为 51.7%，并不能自信地将 Beercoin 报告为易受攻击的。除了这种情况之外，我们还必须注意到，在实践中，由于应用场景有限，很多合约都强制执行同构的业务逻辑。它不可避免地会带来很多类似的实现，例如以太币充值/提现、代币转账等。更具体地说，余额检查（例如图 2b 中的第 4 行）和操作（例如加法和减法）、通过调用发送以太币以及一些其他常见操作将频繁发生，并且通常以相同的方式实现。因此，基于匹配的智能合约分析比传统应用程序更容易受到噪声代码的影响。当同质噪声代码主导功能时，与漏洞直接相关的关键操作在代码匹配中将不会受到足够的关注。换句话说，**无漏洞的合约很可能被误检测**。我们将在第 IV-C 节中展示噪声代码可能会导致很多不准确。
>
>  为了解决这些问题，我们提出了面向智能合约字节码的规范化和切片技术来增强字节码匹配。具体来说，我们从两个方面进行归一化以统一不同的字节码以进行匹配，即通过用有意义的标签标记数据值来进行数据归一化，以及通过对操作数重新排序并忽略无关紧要的指令来进行指令归一化。此外，为了削弱噪声代码的干扰，我们通过模拟字节码执行并跟踪数据流和控制流来强制执行合约特定的切片，以增强干净代码集上的字节码匹配。
>
>  ![image-20231015114840601](https://raw.githubusercontent.com/m1crofan/image/main/image-20231015114840601.png)
>
>  遵循基于匹配的技术原理，我们可以将种子和目标合约编码为定量和可测量形式的向量。请注意，除了字节码指令之外，结构信息在面向合约的匹配中也起着重要作用。图3中的一个简单例子可以说明结构信息在匹配中的重要性，其中交换两个语句的顺序（图3b）可以修复图3a中的重入漏洞[11]。为了有效地引入结构信息并避免现有研究[5]、[6]中所做的特征工程，我们设计了一种**端到端的图嵌入算法**，将基于切片的控制流图编码为向量并测量向量相似度用于字节码匹配。如果它们的向量与那些已知的易受攻击的合约高度相似，我们就会利用测量结果来报告潜在的易受攻击的合约。
>
>  我们实现了一个原型，并在超过 200 万个闭源智能合约和约 32,500 个开源合约上对其进行了评估。结果表明，我们的方法**只需使用一些已知的易受攻击的合约作为种子**，就可以有效地捕获数百个漏洞，并且具有高性能和高精度。我们总共检测到 160 个可利用的漏洞，并在私有区块链环境中使用专门开发的攻击负载一一验证。我们还证明了标准化和切片的必要性以及考虑结构信息的有效性。我们的比较分析表明，我们的方法通常优于最先进的检测器。
>
>  还值得注意的是，我们在审计的早期阶段识别了 23 个蜜罐合约 [12]，因为这些蜜罐被伪装成容易受到攻击的攻击者。以未发现的蜜罐合约为种子，通过相同的匹配方法，我们进一步发现了其他 33 个蜜罐。它们的危害性也经过人工验证。
>
>  贡献点
>
>  - 据我们所知，我们是第一个在智能合约字节码匹配中引入图嵌入方法来发现未知漏洞的人。我们提出标准化和切片来解决两个合约的具体问题。
>  - 我们实现一个原型并在现实世界的合同中对其进行评估。实验表明其可扩展性（每个合约 0.47 秒）、高精度（91.95%）我们实现一个原型并在现实世界的合同中对其进行评估。实验表明其可扩展性（每个合约 0.47 秒）、高精度（91.95%）排名第一）和有效性（160 个真阳性，比较分析的准确性更高）。
>  - 我们还使用该方法成功检测了数十个蜜罐合约，进一步说明了我们方法的能力。

### 背景

>EVM
>
>智能合约被编译为字节码并在 EVM 中执行。在执行期间，EVM 维护运行时堆栈、瞬态内存和持久存储。通常，在调用时，输入会加载到堆栈中，EVM 会执行指令来操作堆栈、内存和存储器中的数据。
>
>堆栈充当典型 x86 机器中的寄存器，大多数指令只能操作堆栈中的数据。例如，ADD 指令从堆栈中弹出两个元素，计算它们的和并将结果推回堆栈。内存在运行时保存易失性数据，通常是大小大于 32 字节的数据。 SHA3 计算内存中数据块的哈希值。 MLOAD和MSTORE用于堆栈和内存之间的交互。当执行终止时，堆栈或内存中的数据将被丢弃。存储托管保存在区块链中的数据，并且可以跨不同的执行来跨越其生命周期。换句话说，合约的状态（例如余额）和全局变量（即合约中的字段变量）保存在存储中。指令SLOAD和SSTORE在堆栈和存储器之间交换数据。除了内存块之外，堆栈和存储中数据元素的典型且最大大小为 256 位。
>
>除了上述数据区域和操作之外，如果不满足某些条件，智能合约也可能会异常终止。在这种情况下，EVM 使用 REVERT 等指令恢复存储。当执行在 RETURN 处正常结束时，所有更改都会被保留。
>
>智能合约漏洞:整数溢出、重入、时间戳依赖、访问控制、不处理异常
>
>通常，另一个合约中的被调用者函数可能会引发异常，恢复被调用者合约的状态，然后返回 false 指示执行失败 [11]。但是，异常可能不会传播给调用者。在进一步操作之前不显式检查返回值可能会导致意外行为。下面的示例代码通过send方式实现以太币传输，并在动作前进行余额减法，以避免重入攻击。不幸的是，如果**不检查转账操作是否正确进行**，合约所有者可能会发现余额不一致。
>
>```solidity
>balances[msg.sender] -= _amount;
>msg.sender.send(_amount);
>```
>

### 方法

>我们提出了一种检测智能合约漏洞的方法。高级想法是从智能合约中提取模式并检查是否有任何未知模式可以匹配易受攻击的模式。图 5 展示了我们方法的溢出。对于给定的智能合约，无论是未知的还是具有已知漏洞的，我们都会预处理字节码并构建控制流图（CFG），基于此我们查明切片标准并在字节码执行模拟之上提取相应的切片。然后我们对切片进行归一化，然后使用图嵌入网络对面向切片的控制流图进行矢量化。最后，我们通过测量成对相似性来测试表示目标合约中的切片的向量是否可以与易受攻击的切片的任何向量相匹配，并报告具有高相似性的潜在易受攻击的合约。我们将在下面的部分中详细介绍这些步骤。
>
>#### **A 预处理和切片**
>
>智能合约字节码不直接随指令携带操作数信息。相反，除 PUSH 系列之外的所有指令都从运行时堆栈获取其操作数。如果没有关联的堆栈，我们就无法知道 JUMP 指令的目的地，或者 ADD 指令的任一操作数是否源自输入。正如许多其他方法 [11]、[14] 中所做的那样，我们模拟字节码执行并构造 CFG。除了模拟之外，我们**还跟踪数据流和控制流**，并根据专门的切片标准执行切片。
>
>1）切片标准：回顾第二节中感兴趣的漏洞。我们认为来自智能合约外部的所有数据，包括区块链上的数据（例如时间戳和用户余额），都有机会被对手控制。对此类数据的不当操作很容易被利用。因此，我们提取与此类数据相关的指令序列作为潜在的易受攻击的行为。具体来说，我们决定以下四种类型的切片标准。首先，我们关心用户通过调用提供的交易数据。 CALLDATALOAD、CALLER、CALLVALUE 等指令从输入中加载交易数据以供后续操作。其次，考虑可以通过BLOCKHASH、TIMESTAMP等指令从区块链中检索的区块数据。第三，我们认为表示智能合约内部状态的存储数据发挥着重要作用。指令SLOAD从存储器中获取数据。最后，外部调用的返回值也可能受到对手的影响，导致意外行为，因此我们考虑了 CALL 等相关指令。
>
>2）切片：采用模拟执行来跟踪数据和控制流并了解指令之间的依赖性，我们利用经典的切片算法[15]从将上述四种数据引入运行时堆栈的指令开始提取切片。特别是，我们遍历每条可达路径来收集相关指令。值得注意的是，我们的切片过程在两个方面与经典切片算法不同。
>
>首先，我们在切片中包含表示异常终止的指令，例如 REVERT 和 INVALID，正如我们前面提到的，它们丢弃当前执行中的所有更改，但不接受任何操作数。此类指令很重要，因为它们可能**表明确实保证了执行安全的失败断言**。在没有数据依赖于感兴趣的数据 DI的情况下，如果到达此类指令的特定路径在任何数据区域（例如堆栈）中留下从 DI 导出的数据，则它们会被放入切片中。
>
>其次，虽然字节码指令通常不携带任何显式数据，但我们将数据操作数与操作码相关联以形成切片中的节点。操作数携带着区分指令工作场景的重要信息。例如，ADD 在一个片中计算两个输入整数的结果，但在另一个片中计算内存偏移量。指令操作码 ADD 本身并不能告诉我们很多场景，**但相关的操作数给了我们一个区分它们的机会**。最终，切片中的节点由操作码和ADD(op1, op2)形式的数据组成。请注意，输入等未知数据由抽象符号表示。
>
>![image-20231015122047387](https://raw.githubusercontent.com/m1crofan/image/main/image-20231015122047387.png)
>
>3）示例：在图 6 中，我们展示了图 3a 中金额的切片。我们消除了包括 MSTORE、SHA3 和 SLOAD 在内的不相关指令，并获得了一个简洁的序列，所有指令操作的数据均来自切片准则，显着减少了噪声代码的干扰。
>
>#### **B 标准化**
>
>切片消除了不相关的指令，但正如我们之前提到的，不同的编译器可能会导致差异，阻碍字节码匹配。在本节中，我们将介绍两种标准化技术，尽可能统一相似源代码片段的切片切片消除了不相关的指令，但正如我们之前提到的，不同的**编译器**可能会导致差异，阻碍字节码匹配。在本节中，我们将介绍两种标准化技术，尽可能统一相似源代码片段的切片。
>
>1）数据标准化 ：我们已将数据附加到相应的操作码以形成切片中的节点。然而，仅通过检查值来确定两个片中的指令是否实际上执行非常相似的操作是不够的。由于智能合约字节码中的所有值都可视为 256 位整数，因此许多前人的作品 [6]、[16]、[17] 所采用的粗粒度值类型都不够充分。
>
>![image-20231015122654955](https://raw.githubusercontent.com/m1crofan/image/main/image-20231015122654955.png)
>
>2）指令标准化：按字母顺序对标准化标签进行重新排序通常用于标准化[16]，这有助于减少对相同数据的操作之间的差异。例如，在任何情况下，我们都应该考虑 ADD(calldata,literal) 和 ADD(literal,calldata) 确实做同样的事情。我们调整一个操作数的标签顺序。然而，为了保留实用性，我们仅对算术/位运算 ADD、MUL、AND、OR 和 XOR 以及比较指令 EQ、LT、GT、SLT 和 SGT 的操作数重新排序。前者加上EQ，改变操作数的位置后没有副作用。如果发生重新排序，则剩余的比较指令可以用相反的操作码替换。例如，我们为上例中的两条指令创建ADD(calldata,literal)，并为LT(literal,calldata)生成新的符号GT(calldata,literal)。
>
>此外，片可能包含仅移动或复制堆栈中数据的指令，例如图 6 中的 DUP1 和 SWAP1。DUP 和 SWAP 系列有 16 个变体，即 DUP1 ∼ DUP16 和 SWAP1 ∼ SWAP16。根据编译器的不同，相同的源代码可能会转换为具有不同 DUP/SWAP 指令的序列。此外，它们通常与比较指令一起使用来构造等效行为，例如“SWAP，GT”与“LT”。由于此类指令与 POP 一起与源代码中描述的行为松散相关，因此我们认为它们在代码匹配中无关紧要，因此忽略切片中的所有 DUP、SWAP 和 POP 指令。此外，片可能包含仅移动或复制堆栈中数据的指令，例如图 6 中的 DUP1 和 SWAP1。DUP 和 SWAP 系列有 16 个变体，即 DUP1 ∼ DUP16 和 SWAP1 ∼ SWAP16。根据编译器的不同，相同的源代码可能会转换为具有不同 DUP/SWAP 指令的序列。此外，它们通常与比较指令一起使用来构造等效行为，例如“SWAP，GT”与“LT”。由于此类指令与 POP 一起与源代码中描述的行为松散相关，因此我们认为它们在代码匹配中无关紧要，因此忽略切片中的所有 DUP、SWAP 和 POP 指令。
>
>3）示例：我们在图 7 中显示了一个示例来证明所提出的标准化的有效性。第一个切片是图 6 中的切片，第二个切片是从编译器 v0.4.25 生成的字节码中提取的。通过归一化技术，我们获得相同的标记切片，这有助于我们快速识别两个原始切片中的相同行为，从而有利于代码匹配。
>
>![image-20231015150151704](https://raw.githubusercontent.com/m1crofan/image/main/image-20231015150151704.png)
>
>#### C. 图嵌入
>
>我们获得了统一的切片，目的是将它们嵌入到向量空间中进行相似性测量。为了捕获更多结构信息，我们将每个切片转换为控制流图，并参考 graph2vec [18] 进行端到端的图嵌入，而不是像 Gemini [5] 那样将每个节点矢量化，然后将节点矢量聚合为一个图矢量。其主要思想是将图中节点周围的有根子图视为单词，将图视为文档。学习目标是从图中提取的有根子图在图中出现的可能性最大化。通过遵循文档嵌入过程，graph2vec 可以迭代学习相应图的表示。从理论上讲，与基于线性子结构的图嵌入技术相比，graph2vec 可以捕捉到更多细微的结构信息[19]。
>
>在本研究中，将每条指令视为一个节点，将一个切片视为图，算法 1 描述了如何将切片 {Gi } 嵌入到每个智能合约 C 的向量 {VGi } 中。该算法的关键在于更新有根子图和整个图的嵌入，使切片的学习向量与其有根子图向量接近，但尽可能远离其他子图向量。
>
>
>
>
