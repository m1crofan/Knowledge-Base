### 线性表的顺序存储

线性表的顺序表示指的是**用一组地址连续的存储单元**一次存储线性表的数据元素，每一个数据元素的存储位置都和线性表的起始位置相差一个常数，这个常数和数据元素在线性表中的位序成正比，所以线性表的顺序存储结构是一种**随机存取**的存储结构。

>随机存取指的是：存和取都不受数据的物理位置影响。

在C语言中可用动态分配的一维数组表示线性表

```c
#define MAXSIZE 100		//	顺序表可能达到的最大长度
typedef struct
{
    ElemType *elem;		//	存储空间的基地址
    int	length;			//	当前长度
}SqList；				// 顺序表的结构类型为Sqlist
```

>![image-20231026230201108](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026230201108.png)
>
>![image-20231026230428801](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026230428801.png)
>
>![image-20231026231318493](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026231318493.png)
>
>![image-20231026231539323](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026231539323.png)
>
>传值方式
>
>- 把实参的值传递给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变。
>
>![image-20231026232727912](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026232727912.png)
>
>![image-20231026232747419](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026232747419.png)
>
>![image-20231026233126841](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026233126841.png)
>
>什么是引用？？？
>
>引用：它用来给对象提供一个替代的名字
>
>下图中，m和a共用一个空间；n和b共用一个空间。
>
>这样做的目的是：使得对形参的操作就是对形参的操作。
>
>![image-20231026233536706](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026233536706.png)
>
>![image-20231026233843833](https://raw.githubusercontent.com/m1crofan/image/main/image-20231026233843833.png)

用顺序存储结构表示多项式

```c
#define MAXSIZE 100		//多项式可能达到的最大长度
typedef struct
{
    float coef;			//系数
    int	expn;			//指数
}Polynomial;
typedef struct
{
    Polynomial *elem;	//存储空间的基地址
    int length;			//多项式中当前项的个数
}SqList;				//多项式的顺序存储结构类型为SqList
```

图书表的顺序存储结构的类型定义如下：

```c
#define MAXSIZE 10000
typedef struct
{
    char no[20];	//图书ISBN
    char name[50];	//图书的名字
    float price;	//图书价格
}Book;
typedef struct
{
    Book *elem;		//存储空间的基地址
    				//定义了一个指向Book类型的指针
    int	length;		//图书表中当前图书个数
}SqList;			//图书表的顺序存储结构类型为SqList
```

在上述定义后，可以通过变量定义语句

```c
SqList L;
```

将L定义为SqList类型的变量，便可以利用L.elem[i-1]访问表中位置序号为i的图书记录。

### 顺序表中基本操作的实现

#### 1.初始化

算法步骤

- 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。
- 将表的当前长度设为0

```c
status InitList(SqList &L)
{//构造一个空的顺序表L
    L.elem = new ElemType[MAXSIZE];		//为顺序表分配一个大小为MAXSIZE的数组
    if(!L.elem)	exit(OVERFLOW);		//存储分配失败退出
    L.length = 0
    return OK;
}
```

#### 2. 取值

取值操作是根据指定的位置序号i，获取顺序表中第i个数据元素的值。

由于顺序存储结构具有随机存取的特点，可恶意直接通过数组下标定位得到，elem[i-1]单元存储第i个数据元素。

算法步骤

- 判断指定的位置序号i值是否合理（1 ≦ i ≦ L.length），若不合理，则返回ERROR。
- 若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的传值。

```c
Status GetElem(SqList L,int i,ElemType &e)
{
    if(i<1 || i>L.lenngth) return ERROR;	//判断i值是否合理，若不合理，返回ERROR
    e = L.elem[i-1];	//elem[i-1]单元存储第i个数据元素
    return OK;
}
```

