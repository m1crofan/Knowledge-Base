### 摘要

>近年来，由于黑客攻击造成的巨大损失，智能合约漏洞检测受到广泛关注。现有的合约安全分析工作严重依赖于专家定义的严格规则，这是劳动密集型且不可扩展的。更重要的是，专家定义的规则往往容易出错，并且存在被狡猾的攻击者欺骗的固有风险。最近的研究重点是用于漏洞检测的智能合约的符号执行和形式分析，但尚未实现精确且可扩展的解决方案。尽管已经提出了多种方法来检测智能合约中的漏洞，但仍然缺乏考虑将专家定义的安全模式与深度神经网络相结合的努力。
>
>在本文中，我们探索使用图神经网络和专家知识进行智能合约漏洞检测。具体来说，我们将源代码丰富的控制和数据流语义转换为契约图。为了突出图中的关键节点，我们进一步设计了节点消除阶段来规范化图。然后，我们提出了一种新颖的时间消息传播网络，从归一化图中提取图特征，并将图特征与设计的专家模式相结合以产生最终的检测系统。对以太坊和VNT Chain平台上**所有有源代码的智能合约**进行了广泛的实验。实证结果表明，在三种类型的漏洞上，我们的方法的检测精度比最先进的方法有显着的提高，其中对于可重入、时间戳依赖和无限循环漏洞，我们的方法的检测精度达到 89.15%、89.02% 和 83.21%。分别。

### 引言

> 区块链及其杀手级应用，例如比特币和智能合约，正在席卷全球。区块链本质上是一个分布式、共享的交易账本，由区块链网络中的所有矿工遵循共识协议维护。共识协议和复制账本强制所有交易一旦记录在链上就不可篡改，赋予区块链去中心化和不可篡改的性质。
>
> 智能合约
>
> 智能合约是运行在区块链之上的程序 。智能合约可以通过将规则编码到源代码中来实现管理资产的任意规则。合约的定义规则在执行过程中将被严格自动遵循，实现“代码就是法律”的逻辑。智能合约使合同条款的自动执行成为可能，从而促进复杂的去中心化应用程序（DApp）。事实上，许多DApp基本上都是由多个智能合约作为后端和用户界面作为前端组成。
>
> 数以百万计的智能合约已部署在各种区块链平台上，实现了广泛的应用，包括钱包、众筹、去中心化赌博和跨行业金融。智能合约的数量仍在快速增长。例如，在过去六个月中，仅在最著名的智能合约平台以太坊上就部署了超过 15,000 个新合约。
>
> 智能合约的安全问题
>
> 目前，各领域的智能合约持有价值超过 100 亿美元的虚拟币。毫无疑问，持有如此多的财富使得智能合约对攻击者有足够的吸引力。2016 年 6 月，攻击者利用 DAO 合约的重入漏洞窃取了 360 万个以太币，价值 6000 万美元。这个案例并不是孤立的，每隔几个月就会有几个安全漏洞被发现和利用，破坏了人们对基于智能合约的应用程序的信任。
>
> 有多种原因导致智能合约特别容易出错。首先，编程语言（例如 Solidity）和工具仍然是新的和粗糙的，为工具中的错误和误解留下了足够的空间。其次，由于智能合约一旦部署就不可更改，因此开发者需要预见合约未来可能遇到的所有可能的状态和环境，这无疑是困难的。与传统的分布式应用程序可以在检测到错误时进行更新不同，智能合约的错误无法在不分叉区块链的情况下修补（几乎是不可能的任务），无论合约持有多少钱或有多受欢迎。因此，在智能合约被开发之前，需要对其进行有效的漏洞检查。
>
> 传统方法的缺点
>
> 传统的智能合约漏洞检测方法，例如，采用经典的静态分析或动态执行技术来识别漏洞。不幸的是，它们从根本上依赖于几种专家定义的模式。手动定义的模式具有容易出错的固有风险，并且一些复杂的模式很难被覆盖。粗暴地使用几种严格的模式会导致较高的误报率和漏报率，而狡猾的攻击者可以使用技巧轻松绕过模式检查。而且，随着智能合约数量的迅速增加，少数专家不可能筛选所有合约来设计精确的模式。一个可行的解决方案可能是：要求每个专家对多个合约进行标记，然后收集许多专家的所有标记合约来训练一个模型，该模型可以自动预测合约是否存在特定类型的漏洞。
>
> 最近，人们努力采用深度神经网络进行智能合约漏洞检测，以提高准确性。利用基于 LSTM 的网络顺序处理源代码，而将源代码建模为控制流图。构建了一个顺序模型来分析以太坊操作代码。然而，这些方法要么将源代码或操作代码视为文本序列而不是语义块，要么无法突出显示数据流中的关键变量，导致语义建模不充分且结果不令人满意。
>
> 为了填补研究空白，在本文中，我们研究了超过 300,000 个智能合约功能，并提出了一种完全自动化且可扩展的方法，可以检测功能级别的漏洞。具体来说，我们将源代码丰富的控制和数据流语义转换为图形。图中的节点表示关键变量和函数调用，而有向边捕获它们的时间执行轨迹。由于并非图中的所有节点都同等重要，并且大多数图神经网络在图上的信息传播过程中本质上是平坦的，因此我们设计了一个节点消除阶段来规范化图并突出关键节点。然后将归一化的图输入时间消息传播网络以学习图特征。同时，我们利用专业知识从源代码中提取安全模式特征。最后结合图特征和安全模式特征产生最终的漏洞检测结果。
>
> 我们对以太坊中所有有源代码的 40k 合约以及 VNT 链中的所有合约进行了实验，证明了相对于最先进的漏洞检测方法的显着改进：F1 分数从 78% 到 86%，从 79% 到 79%。对于重入、时间戳依赖和无限循环漏洞，分别为 88%、74% 至 82%。我们发布的实现1是为了促进未来的研究。
>
> 我们想指出的是，这项工作在三个方面与之前的工作明显不同：
>
> 1）这项工作是研究图神经网络与传统专家模式的结合是否可以实现**获得了更好的漏洞检测结果**，而前期工作的目标是探索利用神经网络进行智能合约漏洞检测的可能性。
>
>  2）在这项工作中，我们建议提取特定于漏洞的专家模式并将其与图特征相结合。我们还显式地对数据流中的关键变量进行建模。相比之下，在之前的工作中，我们只利用图特征，而忽略专家模式和关键变量。
>
>  3）这项工作在不同的漏洞上始终优于前一项工作，并且总体上提供了该领域的更多见解和发现。请注意，在上一篇论文中，我们提出了两种神经网络DR-GCN和TMP，以探索不同图神经网络在智能合约漏洞检测上的适用性。在本文中，我们重点关注扩展 TMP，它提供比 DR-GCN 更好的性能。我们还将扩展 DR-GCN 并将其与 TMP 的扩展进行比较。
>
> 贡献点
>
>  • 据我们所知，我们是第一个研究融合传统专家模式和图神经网络提取特征以进行智能合约漏洞检测的想法的人。 
>
> • 我们建议将合约函数源代码描述为合约图。我们还显式地规范化图表以突出显示关键变量和调用。提出了一种新颖的时间消息传播网络来自动捕获语义图特征。
>
>  • 我们的方法在智能合约漏洞检测方面设定了新的最先进的性能，并总体上提供了对挑战和机遇的见解。作为附带贡献，我们发布了我们的实现以促进未来的研究。

### 相关工作

> 智能合约漏洞检测
>
> 图神经网络

### 问题陈述

> 在本节中，我们首先阐述问题，然后介绍本文研究的三类漏洞，并提出关注这三种漏洞的原因。
>
> 问题表述。考虑到智能合约的源代码，我们有兴趣开发一种完全自动化的方法，可以检测功能级别的漏洞。换句话说，我们要估计每个智能合约函数 f 的标签 ˆ y ，其中 ˆ y = 1 表示 f 具有特定的漏洞，而 ˆ y = 0 表示 f 是安全的。在本文中，我们重点关注三种类型的漏洞，如下所示。在此之前，我们先介绍一下智能合约中回退机制的初步知识，这对于理解问题很重要。回退机制。在智能合约中，每个函数都由签名唯一标识，由其名称和参数类型组成[31]。函数调用时，被调用函数的签名将传递给被调用的合约。如果签名与被调用合约的函数匹配，则执行跳转到相应的函数。否则，它会跳转到后备函数。转账被视为空签名，这也会触发后备功能。回退函数是一种没有名称、没有参数的特殊函数，**可以任意编程**[31]。介绍完这些背景知识后，我们现在准备详细阐述这三类漏洞。
>
> ![image-20230927181548412](https://raw.githubusercontent.com/m1crofan/image/main/image-20230927181548412.png)
>
>  可重入性是一个众所周知的漏洞，导致了臭名昭著的 DAO 攻击。当智能合约函数 f1 向接收合约 C 转账时，C 的回退函数 f2 将自动执行。在其回退函数f2中，C可以调用回f1以进行非法的第二次传输。由于f1当前执行等待第一次转账完成，C可以利用f1的中间状态成功盗钱。一个简化的例子如图 1 所示，合约 Bank 的提现函数存在重入漏洞，合约 Attacker 利用该漏洞窃取资金。
>
> 首先，攻击者将 10 个以太币（以太币是以太坊的虚拟货币）存入合约银行（步骤 1）。然后，攻击者通过调用提现函数提取 10 个以太币（步骤 2）。当合约 Bank 使用 call.value（Bank，第 9 行）向 Attacker 发送 10 以太币时，Attacker 的后备函数（Attacker，第 8-11 行）将被自动调用（步骤 3）。在其后备函数中，攻击者再次调用withdraw（步骤4）。由于攻击者的 userBalance 尚未设置为 0（银行，第 10 行），银行认为攻击者合约中仍有 10 个以太币，因此再次将 10 个以太币转移给攻击者（步骤 5）。提现循环持续 9 次（计数 + + < 10，攻击者线 9）。最后，攻击者获得的以太币（100 以太币）比预期（10 以太币）多得多。

### 我们的方法

![image-20230927181901353](https://raw.githubusercontent.com/m1crofan/image/main/image-20230927181901353.png)

> 我们提出的方法的整体架构如图2所示，它由三个阶段组成：
>
> （1）安全模式提取阶段，从源代码中获取特定于漏洞的专家模式； 
>
> （2）合约图构建和规范化阶段，从源代码中提取控制流和数据流语义并突出关键节点；
>
>  (3)漏洞检测阶段，利用时态图神经网络将归一化合约图转化为图特征，并将模式特征和图特征结合起来输出检测结果。下面我们对这三个部分的细节一一进行阐述。
>
> 专家模式提取
>
> 在本节中，我们总结现有模式并分别针对三个特定漏洞设计新模式，并实现一个开源工具来自动提取这些模式。
>
> 可重入性。传统上，重入漏洞被认为是对 call.value 的调用，可以通过调用链回调自身。即重新调用call.value成功，进行意外的重复转账操作。通过研究[8,17,27]等现有作品，我们设计了三个子模式。
>
> - 第一个子模式是 callValueInvocation，它检查函数中是否存在对 call.value 的调用。
> - 第二个子模式balanceDeduction通过call.value检查转账后是否扣除用户余额，考虑到每次转账前扣除用户余额可以避免被盗的情况。
> - 第三个子模式不够余额涉及在转移给用户之前是否检查用户余额是否充足。请注意，enoughBalance 是本文设计的新模式。
>
> 模式提取实现。我们实现了一个开源工具来从智能合约功能中提取设计的专家模式。特别是，简单的子模式，如callValueInitation、timestampInitation、loopStatement，可以通过关键字匹配直接提取。通过语法分析得到子模式balanceDeduction、enoughBalance、loopCondition、timestampAssign、selfInvocation。复杂子模式时间戳污染是通过污点分析提取的，我们跟踪数据流的踪迹并标记沿踪迹可能受影响的所有变量。
>
> 合约图的构建及其标准化
>
> 现有的工作[35, 48]已经表明，程序可以转换为符号图表示，它能够保留程序元素之间的语义关系（例如，数据依赖性和控制依赖性）。受此启发，我们将智能合约功能制定为合约图，并为不同的程序元素（即节点）分配不同的角色。我们还构建边来对程序元素之间的控制和数据流进行建模，并考虑它们的时间顺序。此外，我们设计了一个节点消除过程来规范合约图并突出重要节点。接下来，我们分别介绍合约图构建和标准化。
>
> 节点构建
>
> ![image-20230927183149792](https://raw.githubusercontent.com/m1crofan/image/main/image-20230927183149792.png)
>
> 我们的第一个见解是，函数中的不同程序元素在检测漏洞方面的**重要性并不相同**。因此，我们提取三种类型的节点，即核心节点、普通节点和后备节点。核心节点象征着对于检测特定漏洞至关重要的关键调用和变量。特别是，对于重入漏洞，*核心节点*模型（i）对转账函数或内置call.value函数的调用，（ii）与用户余额对应的变量，以及（iii）可以直接影响的变量用户余额。核心节点代表关键的调用和变量，而*普通节点*则用于对调用和变量进行建模，在漏洞检测中起辅助作用。具体来说，未提取为核心节点的调用和变量被建模为普通节点。进一步，我们构建了一个后备节点F来激发虚拟攻击合约的后备功能，它可以与被测功能进行交互。一个简化的例子。以图 3 左侧所示的漏洞合约为例，假设我们要评估其提现函数是否存在重入漏洞。如图3左两图箭头所示，函数withdraw本身首先被建模为核心节点C1，因为其内部代码包含call.value。然后，按照代码的时间顺序，我们将关键变量 Balance[msg.sender] 视为核心节点 C2，而变量 amount 则建模为普通节点 N1。对call.value的调用被提取为核心节点C3，虚拟攻击合约的后备功能由后备节点F表征。
>
> 边的构建
>
> 我们的第二个见解是，节点在时间上彼此紧密相关，而不是孤立的。为了捕获节点之间丰富的语义依赖关系，我们构造了三类边，即控制流、数据流和后备边。每条边都描述了被测函数可能遍历的路径，边的时间编号表征了它在函数中的顺序。
>
> ![image-20230927183914999](https://raw.githubusercontent.com/m1crofan/image/main/image-20230927183914999.png)
>
> 控制流动边
>
> 控制流边捕获代码的控制语义。具体地，控制流边是针对条件语句或安全句柄语句（例如if、for、assert和require语句）构造的。边从遇到的前一个节点（表示当前语句之前的关键函数调用或变量）指向表示当前语句中的函数调用或变量的节点。特别是，我们使用前向边来描述代码序列的自然控制流。前向边连接相邻语句中的两个节点。这种编码的主要好处是保留源代码序列所反映的编程逻辑。控制流边缘如图3中的红色箭头所示。
>
> 数据流边
>
> 数据流边跟踪变量的使用情况。数据流边涉及变量的访问或修改。数据流边在图 3 中用橙色箭头表示。例如，访问和分配语句 Balance[msg.sender]-=amount（第 8 行，易受攻击的图 3）具有两个数据流边缘的特征，即，从 Balance[msg.sender] 变量节点 C2 开始到自身的访问边 e7，以及从 C2 开始到 amount 变量节点 N1 的分配边 e8。
>
> 回退边
>
> 为了明确地建模特定的后备机制，构造了两个后备边。第一个后备边从第一个 call.value 调用连接到后备节点，而第二条边从后备节点指向被测试的函数。图 3 中的紫色虚线显示了后备边缘。
>
> ![image-20230927184214021](https://raw.githubusercontent.com/m1crofan/image/main/image-20230927184214021.png)
>
> 节点和边缘特征。图 4 分别说明了提取的边和节点特征。具体来说，将边的特征提取为元组（Vstart，Vend，Order，Type），其中Vstart和Vend表示其开始和结束节点，Order表示其时间顺序，Type表示边类型。对于节点来说，不同类型的节点具有不同的特征。 1）对函数调用进行建模的节点的特征由（ID，AccFlag，Caller，Type）组成，其中ID表示其标识符，Caller表示调用的调用者地址，T ype表示节点类型。有趣的是，智能合约函数 ψ 的修改者可能会触发某些条件的预检查，例如，修改者所有者会在执行 ψ 之前检查 ψ 的调用者是否是合约的所有者。因此，我们使用 AccFlag 来捕获此语义，其中 AccFlag = ‘LimitedACC’ 指定该函数具有有限访问权限，而 AccFlag =‘NoLimited’ 表示不受限制访问。 2) 相比之下，后备节点或节点的特征。

