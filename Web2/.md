```solidity
contract ContractA {
  uint256 private _totalSupply;
  uint256 private _allstake;
  mapping (address => uint256) public _balances;
  bool check=true;

  modifier noreentrancy(){
    require(check);
    check=false;
    _;
    check=true;
  }

  function get_price() public view virtual returns (uint256) {
    if(_totalSupply==0||_allstake==0) return 10e8;
    return _totalSupply*10e8/_allstake;
  }

  function deposit() public payable noreentrancy(){
    uint256 mintamount=msg.value*get_price()/10e8;
    _allstake+=msg.value;
    _balances[msg.sender]+=mintamount;
    _totalSupply+=mintamount;
  }

  function withdraw(uint256 burnamount) public noreentrancy(){
    uint256 sendamount=burnamount*10e8/get_price();
    _allstake-=sendamount;
    payable(msg.sender).call{value:sendamount}("");
    _balances[msg.sender]-=burnamount;
    _totalSupply-=burnamount;
  }
}
```

```solidity
contract ContractB {

  ContractA contract_a;
  mapping (address => uint256) private _balances;
  bool check=true;

  modifier noreentrancy(){
    require(check);
    check=false;
    _;
    check=true;
  }

  function setcontracta(address addr) public {
    contract_a = ContractA(addr);
  }

  function depositFunds() public payable noreentrancy(){
    uint256 mintamount=msg.value*contract_a.get_price()/10e8;
    _balances[msg.sender]+=mintamount;
  }

  function withdrawFunds(uint256 burnamount) public payable noreentrancy(){
    _balances[msg.sender]-=burnamount;
    uint256 amount=burnamount*10e8/contract_a.get_price();
    msg.sender.call{value:amount}("");
  }
  function balanceof(address acount)public view returns (uint256){
    return _balances[acount];
  }
}
```

