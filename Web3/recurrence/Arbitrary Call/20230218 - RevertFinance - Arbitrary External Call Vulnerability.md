漏洞函数

[交易信息](https://dashboard.tenderly.co/tx/mainnet/0xdaccbc437cb07427394704fbcc8366589ffccf974ec6524f3483844b043f31d5/debugger?trace=0.4.0)

攻击者：0x38f887a0fe01b9e4960d5c727519408fa7f32f70

攻击合约：0xd346f652a56d149d585b5447851928f42f61fb27

漏洞合约：0x531110418d8591C92e9cBBFC722Db8FFb604FAFD

以下是漏洞关键函数swap和_swap

```solidity
    function swap(SwapParams calldata params) external payable returns (uint256 amountOut) {

        _prepareAdd(params.tokenIn, IERC20(address(0)), IERC20(address(0)), params.amountIn, 0, 0);

        uint amountInDelta;
        (amountInDelta, amountOut) = _swap(params.tokenIn, params.tokenOut, params.amountIn, params.minAmountOut, params.swapData);

        // send swapped amount of tokenOut
        if (amountOut > 0) {
            _transferToken(params.recipient, params.tokenOut, amountOut, params.unwrap);
        }

        // if not all was swapped - return leftovers of tokenIn
        uint leftOver = params.amountIn - amountInDelta;
        if (leftOver > 0) {
            _transferToken(params.recipient, params.tokenIn, leftOver, params.unwrap);
        }
    }
    
    
function _swap(IERC20 tokenIn, IERC20 tokenOut, uint amountIn, uint amountOutMin, bytes memory swapData) internal returns (uint amountInDelta, uint256 amountOutDelta) {
        if (amountIn > 0 && swapData.length > 0 && address(tokenOut) != address(0)) {
            uint balanceInBefore = tokenIn.balanceOf(address(this));
            uint balanceOutBefore = tokenOut.balanceOf(address(this));

            // get router specific swap data
            (address swapRouter, address allowanceTarget, bytes memory data) = abi.decode(swapData, (address, address, bytes));

            // approve needed amount
            tokenIn.approve(allowanceTarget, amountIn);

            // execute swap
            (bool success,) = swapRouter.call(data);
            if (!success) {
                revert SwapFailed();
            }

            // remove any remaining allowance
            tokenIn.approve(allowanceTarget, 0);

            uint balanceInAfter = tokenIn.balanceOf(address(this));
            uint balanceOutAfter = tokenOut.balanceOf(address(this));

            amountInDelta = balanceInBefore - balanceInAfter;
            amountOutDelta = balanceOutAfter - balanceOutBefore;

            // amountMin slippage check
            if (amountOutDelta < amountOutMin) {
                revert SlippageError();
            }

            // event for any swap with exact swapped value
            emit Swap(address(tokenIn), address(tokenOut), amountInDelta, amountOutDelta);
        }
    }

```

漏洞成因：在V3Utils合约中

![image-20230722204852491](https://raw.githubusercontent.com/m1crofan/image/main/image-20230722204852491.png)

`swap`函数调用`_swap`的参数外部可控，而`_swap`使用了call方法去调用`swapRouter`合约。因此，恶意攻击者能调用`swapRouter`该合约的任意函数。

![image-20230722205358381](https://raw.githubusercontent.com/m1crofan/image/main/image-20230722205358381.png)
