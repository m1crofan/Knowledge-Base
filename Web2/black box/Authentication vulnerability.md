### 身份验证漏洞

从概念上讲，身份验证漏洞很容易理解。但是，由于身份验证和安全性之间存在明确的关系，它们通常至关重要。

身份验证漏洞可能允许攻击者访问敏感数据和功能。它们还暴露了额外的攻击面，以便进一步利用。因此，了解如何识别和利用身份验证漏洞以及如何绕过常见的保护措施非常重要。

身份验证是验证用户或客户端身份的过程。网站可能会暴露给连接到互联网的任何人。这使得强大的身份验证机制成为有效Web安全不可或缺的一部分。

身份验证主要有三种类型

- 用户知道的信息，例如密码或安全问题的答案。这些有时被称为“知识因素”
- 用户拥有的东西，这是一个物理对象，例如手机或安全token。
- 用户的生物识别或行为模式

身份验证机制中的大多数漏洞都以以下两种方式之一发生：

- 身份验证机制很弱，因为它们无法充分防止暴力破解
- 实现中逻辑缺陷、设计缺陷允许攻击者绕过身份验证机制。

### Vulnerabilities in password-based login

#### **Brute-foce attack**

>暴力攻击是指攻击者使用试错系统来猜测有效的用户凭据。这些攻击通常使用用户名和密码的单词列表自动进行。自动执行此过程（尤其是使用专用工具）可能会使攻击者能够高速进行大量登录尝试。
>
>暴力破解并不总是只是对用户名和密码进行完全随机猜测的情况。**通过使用基本逻辑或公开知识，攻击者可以微调暴力攻击，以做出更有根据的猜测。**这大大提高了此类攻击的效率。依赖基于密码的登录作为对用户进行身份验证的唯一方法的网站，如果它们没有实施足够的暴力保护，则可能非常容易受到攻击。
>
>**暴力破解用户名**
>
>用户名是否符合可识别的模式（例如电子邮件地址），则特别容易猜测。例如，以格式查看业务登录信息是很常见 `firstname.lastname@somecompany.com` 的。但是，即使没有明显的模式，有时甚至会使用可预测的用户名（例如 `admin` 或 `administrator` ）创建高特权帐户。
>
>在审核过程中，检查网站是否公开披露了潜在的用户名。例如，您是否能够在不登录的情况下访问用户配置文件？即使配置文件的实际内容是隐藏的，**配置文件中使用的名称有时也与登录用户名相同**。您还应该检查HTTP响应，看看是否有任何电子邮件地址被泄露。有时，响应包含高特权用户（如管理员或 IT 支持人员）的电子邮件地址。
>
>**暴力破解密码**
>
>密码同样可以是暴力破解的，难度因密码的强度而异。许多网站采用某种形式的密码策略，这迫使用户创建高熵密码，至少在理论上，仅使用暴力破解更难破解。这通常涉及使用以下方式强制执行密码：
>
>- 最小字符数
>- 小写字母和大写字母的混合
>- 至少一个特殊字符
>
>然而，虽然高熵密码很难单独被计算机破解，但我们可以利用人类行为的基本知识来利用用户无意中引入该系统的漏洞。用户通常不会使用随机字符组合创建强密码，而是使用他们可以记住的密码，并尝试将其撬入密码策略。例如，如果 `mypassword` 不允许，用户可以尝试类似 OR `Myp4$$w0rd` 的 `Mypassword1!` 操作。
>
>如果策略要求用户定期更改其密码，则用户通常只需对其首选密码进行微小的、可预测的更改。例如， `Mypassword1!` 变成 `Mypassword1?` 或 `Mypassword2!.`
>
>这种对可能的凭据和可预测模式的了解意味着暴力攻击通常比简单地迭代每个可能的字符组合要复杂得多，因此也更有效。
>
>**用户名枚举**
>
>用户名枚举是指攻击者能够观察网站行为的变化，以确定给定的用户名是否有效。
>
>用户名枚举通常发生在登录页面上，例如，当您输入有效的用户名但密码不正确时，或者当您输入已使用的用户名时，则发生在注册表单上。这大大减少了暴力破解登录所需的时间和精力，因为攻击者能够快速生成有效用户名的候选列表。
>
>在尝试暴力破解登录页面时，应特别注意以下方面的任何差异：
>
>- 状态代码：在暴力攻击期间，对于绝大多数猜测，返回的 HTTP 状态代码可能是相同的，因为大多数猜测都是错误的。如果猜测返回不同的状态代码，则强烈表明用户名正确无误。无论结果如何，网站始终返回相同的状态代码是最佳做法，但并不总是遵循这种做法。
>- 错误消息：有时返回的错误消息会有所不同，具体取决于用户名和密码是否不正确或只有密码不正确。在这两种情况下，网站最好使用相同的通用消息，但有时会出现小的打字错误。仅一个字符的位置会使两条消息截然不同，即使该字符在呈现的页面上不可见也是如此。
>- 响应时间：如果大多数请求的处理响应时间相似，则任何偏离此时间的请求都表明幕后发生了不同的事情。这是猜测的用户名可能正确的另一个迹象。例如，只有当用户名有效时，网站才可能检查密码是否正确。此额外步骤可能会导致响应时间略有增加。这可能很微妙，但攻击者可以通过输入网站需要明显更长的时间才能处理的过长密码来使这种延迟更加明显。
>
>[Lab: Username enumeration via response timing ](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-response-timing)
>
>>该实验设计的目的是通过响应计时做用户枚举；当用户名正确而密码过长时计算哈希的时间会很长，借助这种时间差进行用户名枚举。
>
>>同时，为了绕过后端的IP限制；使用`X-Forwarded-For`头进行绕过。
>
>>chatgpt
>
>>当请求通过一个代理服务器时，代理服务器会将原始客户端的 IP 地址添加到 `X-Forwarded-For` 头部中。这对于识别客户端的真实 IP 地址在一些情况下非常有用，尤其是当请求经过多个中间代理时。
>
>**有缺陷的暴力破解保护**
>
>在攻击者成功入侵帐户之前，暴力攻击很可能会涉及许多失败的猜测。从逻辑上讲，暴力保护围绕着试图使该过程尽可能棘手地自动化并减慢攻击者尝试登录的速度。防止暴力攻击的两种最常见方法是：
>
>- 如果远程用户尝试登录失败次数过多，则锁定他们尝试访问的帐户
>- 如果远程用户的快速连续登录尝试次数过多，则阻止其 IP 地址
>
>这两种方法都提供了不同程度的保护，但都不是无懈可击的，尤其是在使用有缺陷的逻辑实现时。
>
>例如，如果您登录失败的次数过多，您有时可能会发现您的 IP 被阻止。在某些实现中，**如果 IP 所有者成功登录，则失败尝试次数的计数器将重置。**这意味着攻击者只需每隔几次尝试登录自己的帐户即可防止达到此限制。
>
>在这种情况下，仅仅在整个单词列表中定期包含您自己的登录凭据就足以使这种防御几乎毫无用处。
>
>[Lab: Broken brute-force protection, IP block](https://portswigger.net/web-security/authentication/password-based/lab-broken-bruteforce-protection-ip-block)
>
>>自己的账户名密码： wiener、peter
>
>>受害者账户名：carlos
>
>>密码字典：[Candidate passwords ](https://portswigger.net/web-security/authentication/auth-lab-passwords)
>
>>Q：这个实验通过上述方式就可以完成，但问题在于工具使用方法上，怎么在单词列表中定期包含自己的登录凭证呢？
>
>>A：手动设置攻击字典
>
>**账户锁定**
>
>网站试图防止暴力破解的一种方法是在满足某些可疑条件时锁定账户，通常是**一定数量的失败登录尝试**。与正常的登录错误一样，来自服务器的指示账户已锁定的响应也可以帮助攻击者枚举用户名。
>
>[Lab: Username enumeration via account lock](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-account-lock)
>
>![image-20231126193830921](https://raw.githubusercontent.com/m1crofan/image/main/image-20231126193830921.png)
>
>**用户速率限制**
>
>网站防止暴力破解的另一种方法是通过用户速率限制。在这种情况下，在短时间内发出过度的登录请求会导致您的IP地址被阻止。通常，只能通过以下方式之一取消阻止IP：
>
>- 经过一段时间后自动
>- 由管理员手动操作
>- 用户在成功完成验证码后手动完成
>
>用户速率限制有时比帐户锁定更受欢迎，因为它不太容易受到用户名枚举和拒绝服务攻击。但是，它仍然不完全安全。正如我们在前面的实验室中看到的一个例子，攻击者可以通过多种方式操纵其表面上的 IP 以绕过阻止。
>
>由于该限制基于从用户的 IP 地址发送的 HTTP 请求的速率，因此如果**您能弄清楚如何通过单个请求猜测多个密码**，有时也可以绕过此防御。
>
>[Lab: Broken brute-force protection, multiple credentials per request ](https://portswigger.net/web-security/authentication/password-based/lab-broken-brute-force-protection-multiple-credentials-per-request)
>
>>```json
>>{	
>>    "username":"carlos",
>>	"password":"123"
>>}
>>```
>>
>>post请求提交的是json格式的数据，我们可以—》
>>
>>```solidity
>>{
>>    "username":"carlos",
>>	"password":["123",
>>			   "qwer",
>>             	   "password",
>>					]
>>}
>>```

### Vulnerabilities in multi-factor authentication

**多重身份验证中的漏洞**

越来越多的网站要求用户输入密码和来自设备（短信、邮箱）的临时验证码

虽然攻击者有时可能获得密码，但能够同时获得临时验证码的可能性要小很多。因此，双因素身份显然比单因素更安全。然而，与任何安全措施一样，它的安全性取决于其实施。

#### Bypassing two-factor authentication

**绕过双因素认证**

如果系统首先提示用户输入密码，然后在单独的页面上提示用户输入验证码，则用户在输入验证码之前实际上处于“已登录”状态。在这种情况下，值得测试一下，看看是否可以在完成第一个身份验证步骤后直接跳到“仅登录”页面。有时，您会发现网站实际上并没有在加载页面之前检查您是否完成了第二步。

[Lab: 2FA simple bypass ](https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-simple-bypass)

**有缺陷的双因素认证**

有时，双因素身份验证中的逻辑存在缺陷，这意味着用户完成初始登录步骤后，网站不会充分验证同一用户是否正在完成第二步。

例如，用户在第一步中使用其普通凭证登录

```http
POST /login-steps/first HTTP/1.1
Host: vulnerable-website.com
...
username=carlos&password=qwerty
```

然后，他们被分配到一个与其账户相关的cookie，然后进入登录过程的第二步：

```http
HTTP/1.1 200 OK
Set-Cookie: account=carlos

GET /login-steps/second HTTP/1.1
Cookie: account=carlos
```

提交验证码时，请求使用此 cookie 来确定用户尝试访问的帐户：

```solidity
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=carlos
...
verification-code=123456
```

在这种情况下，攻击者可以使用自己的凭据登录，但在提交验证码时将 `account` cookie 的值更改为任意用户名。

```http
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=victim-user
...
verification-code=123456
```

如果攻击者能够暴力破解验证码，这是非常危险的，因为这将允许他们完全根据用户名登录任意用户的帐户。他们甚至不需要知道用户的密码。

[Lab: 2FA broken logic](https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-broken-logic)

>![image-20231126213417833](https://raw.githubusercontent.com/m1crofan/image/main/image-20231126213417833.png)
>
>第二步认证时，仅依靠cookie中的用户名来判断邮箱发给谁、验证码也仅与用户名绑定。
>
>![image-20231126213627950](https://raw.githubusercontent.com/m1crofan/image/main/image-20231126213627950.png)

与密码一样，网站需要采取措施防止暴力破解2FA验证码。这一点尤其重要，因为代码通常是一个简单的4位或6位数字。如果没有足够的暴力破解保护，安全性很差。

一些网站试图通过在用户驶入一定数量的错误验证码时自动注销来防止这种情况发生。这在实践中是无效的，因为攻击者可以通过Burp Intruder创建宏来自动执行此多步骤过程。

[Lab: 2FA bypass using a brute-force attack](https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-bypass-using-a-brute-force-attack)

>这个实验有验证码尝试的次数限制，但如果重新登录则无限制；所以可以反复重新登录夹杂着暴力破解的请求。

### Vulnerabilities in other authentication mechanisms

其他身份验证机制中的漏洞

除了基本的登录功能外，大多数网站还提供补充功能，允许用户管理他们的账户。例如，用户通常**可以在忘记密码时更改密码或重置密码**。这些机制还可能引入可被攻击者利用的漏洞。

一个常见的功能是即使在关闭浏览器会话后也能保持登录状态。这通常是一个简单的复选框，标记为“记住我”或“让我保持登录状态”。

这种功能通常是通过生成某种 "记住我 "的标记来实现的，然后将其存储在一个持久的 Cookie 中。由于拥有这个 cookie 就能有效绕过整个登录过程，因此最好的做法是让人无法猜到这个 cookie。不过，有些网站会根据可预测的静态值（如用户名和时间戳）的连接生成 Cookie。有些网站甚至将密码作为 cookie 的一部分。如果攻击者能够创建自己的账户，那么这种方法就特别危险，因为他们可以研究自己的 cookie，并可能推断出 cookie 是如何生成的。一旦推算出公式，他们就可以尝试暴力破解其他用户的 cookie，从而访问他们的账户。

有些网站认为，如果 Cookie 以某种方式加密，即使使用静态值也不会被猜到。如果方法正确，这可能是对的，但使用简单的双向编码（如 Base64）对 Cookie 进行天真地 "加密"，根本无法提供任何保护。即使使用适当的加密和单向散列函数也不是完全无懈可击的。如果攻击者能够轻松识别散列算法，并且没有使用盐，那么他们就有可能通过简单地散列他们的字表来暴力破解 cookie。如果没有对 Cookie 猜测应用类似的限制，这种方法可用于绕过登录尝试限制。

[Lab: Brute-forcing a stay-logged-in cookie](https://portswigger.net/web-security/authentication/other-mechanisms/lab-brute-forcing-a-stay-logged-in-cookie)

>```solidity
>Cookie: stay-logged-in=d2llbmVyOjUxZGMzMGRkYzQ3M2Q0M2E2MDExZTllYmJhNmNhNzcw
>```
>
>经过base64解码后
>
>```solidity
>wiener:51dc30ddc473d43a6011e9ebba6ca770
>```
>
>经过测试 后面这串数字是MD5的密码
>

重置密码

在实践中，有些用户会忘记密码是理所当然的，因此他们通常会有办法重置密码。由于在这种情况下通常的基于密码的身份验证显然是不可能的，因此网站必须依靠替代方法来确保真实用户正在重置自己的密码。因此，密码重置功能本质上是危险的，需要安全地实现。

重置密码的一种可靠的方法是向用户发送一个唯一的URL，以便用户进入密码重置页面。此方法的安全性较低的实现使用具有**易于猜测的参数的URL**来表示正在重置的账户，例如：

```solidity
http://vulnerable-website.com/reset-password?user=victim-user
```

在此示例中，攻击者可以更改 `user` 参数以引用他们标识的任何用户名。然后，他们将被直接带到一个页面，在该页面中，他们可能会为该任意用户设置新密码。

此过程的更好实现是生成一个高熵、难以猜测的令牌，并基于该令牌创建重置 URL。在最佳情况下，此 URL 不应提供有关正在重置哪个用户的密码的提示。

```url
http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8
```

当用户访问此 URL 时，系统应检查后端是否存在此令牌，如果存在，则检查应该重置哪个用户的密码。此令牌应在短时间内过期，并在重置密码后立即销毁。

但是，有些网站在提交重置表单时**没有再次验证令牌**。在这种情况下，攻击者只需从自己的账户访问重置表单，删除令牌，然后利用此页面重置任意用户的密码即可。

[Lab: Password reset broken logic ](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-reset-broken-logic)

>![r](https://raw.githubusercontent.com/m1crofan/image/main/image-20231128194214618.png)

如果重置电子邮件的URL是动态生成的，则也有可能容易受到密码重置中毒的影响。在这种情况下，攻击者可能会窃取其他用户的令牌并使用它来更改其密码。

[Lab: Password reset poisoning via middleware](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-reset-poisoning-via-middleware)

>此实验室自己的用户名密码是：`wiener` `peter` ；受害者的用户名是`carlos`。
>
>受害者会不小心点击他收到的电子邮件中的任何链接。
