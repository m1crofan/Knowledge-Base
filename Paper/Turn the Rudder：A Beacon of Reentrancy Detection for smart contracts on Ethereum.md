这篇文章的核心就是通过人工的方式去证明了：当前工具的误报率高、不仅仅检查call.value()；用检测到的文件构建了一个新数据集。

引言

​       智能合约是部署在区块链上的程序[1]。由于区块链技术保证了去中心化和可信的权威，智能合约被广泛用于开发游戏、政府和金融等各个领域的去中心化应用程序（DApp）[2]。然而，智能合约也受到区块链不可篡改性的限制[3]。也就是说，合约一旦部署就无法修补。存在漏洞的合约可能会被恶意攻击者利用并导致严重问题，例如经济损失。因此，在部署合约之前确保合约的正确性非常重要。对于合约开发者来说，这在实践中是一项具有挑战性的任务。

​      通过现实世界的攻击或通过理论分析，已经发现了智能合约的许多漏洞[4]-[6]。例如，SWC注册表中记录了37种类型的漏洞[7]，NCC组[8]列出了排名前十的漏洞，例如重入和时间操纵。为了使开发人员能够识别和修复漏洞，人们提出了许多方法来检测合约中的漏洞[5]、[9]、[10]。重入是现有研究广泛研究的一个漏洞，因为它可能导致巨大的财务损失，例如 DAO 攻击[11]造成了约 1.5 亿美元的损失。现有的重入检测方法主要集中在智能合约中的call.value()1操作。在第二节中，我们用一个例子解释了重入问题（见图 1）。重入是由于调用call.value()之后状态变量userbalance的延迟更新导致的。重入检测方法旨在使用符号执行[12]、模糊测试[13]和神经网络[9]等各种技术来发现外部调用可能重复发生的支付。最近两年前进行的两项实证研究[14]、[15]表明，当时的方法可能会检测到许多误报。这些研究中使用的合约是用 Solidity 版本 ≤0.6.0 编写的。在过去的两年里，Solidity 语言经历了多个版本，并且发生了重大变化[16]。受这些研究的启发，许多方法已经升级或新提出。然而，目前还没有针对 **Solidity 版本 >0.6.0 中开发的**合约的最先进的重入检测方法的性能进行大规模研究。此外，尚未确认现有方法是否可以检测到与 call.value() 相关的其他重入问题，因为官方 IDE Remix [17] 似乎能够检测到此类重入问题。

在这项工作中，我们对现有方法检测智能合约重入的能力进行了大规模的实证研究。我们从 Etherscan [18]（领先区块）收集了所有 230,548 个合约的经过验证的 Solidity 代码 以太坊的浏览器和分析平台）于 2021 年 10 月 13 日发布，并选择 Mythril [19] 和 Sailfish [20] 等五个知名或最新的工具，这些工具可以定位合约中可能存在重入问题的有缺陷的功能。过滤掉相同字节码的重复合约后，我们得到了 139,424 个不重复的合约。然后，我们使用这些工具对合约进行分析，得到 21,212 个可重入合约。接下来，我们通过招募 50 名参与者（包括 27 名本科生、21 名硕士和 2 名博士）来手动检查可重入合约的功能缺陷。根据检查结果，我们构建了一组 34 个可重入的真阳性合约和一组 21,178 个不可重入的假阳性合约。我们还分析了真阳性和假阳性的原因。使用两组合同，我们评估这些工具。此外，我们还对过去两年报告的重入攻击合约进行了测试，并使用 Remix 验证了真正的正重入合约。结果如下：1）工具检测到的可重入合约中99.8%以上为误报，原因有8类；

 2）真正的可重入合约都与call.value()相关，其中58.8%可以被Remix发现；

 3）这些工具无法检测**最近受到攻击的合约的重入问题**。根据结果，我们得出结论，现有的重入检测工作性能较差，并且可能已经过时，研究人员应该将注意力从 call.value() 转移到发现和检测新的重入模式。

这篇文章的主要贡献如下：

- 我们研究了五种著名或最近的重入检测工具对 139,424 份智能合约的能力。 

- 我们手动检查工具检测到的 21,212 个可重入合约，并构建一组 34 个可重入的真阳性合约和一组 21,178 个不可重入的假阳性合约。我们进一步总结了八种导致误报的原因，发现所有的真报都是由call.value()引起的。 •

- 我们根据手动构建的两组真实和误报可重入合约来评估工具。此外，我们使用 Remix 验证真实性，并在最近的重入攻击合约上测试该工具。根据结果，我们为研究人员提供富有洞察力的指南。 • 我们在GitHub上发布了我们的实验数据[21]，包括230,548个合约、工具的检测结果以及两组真假正合约，为研究人员今后开展重入检测工作提供基准。
- 我们在 GitHub [21] 上发布了我们的实验数据，包括 230,548 个合约、工具的检测结果以及两组真假正合约，为研究人员今后开展重入检测工作提供基准。

背景

​       智能合约是在区块链上运行的程序。一般来说，智能合约是用 Solidity [16] 编写的，Solidity 是智能合约最流行的语言之一。智能合约的 Solidity 代码被编译为字节码，然后部署在区块链上。此外，编译过程会生成应用程序二进制接口（ABI），以方便后续智能合约的调用和分析。

重入

```solidity
contract simpleDAO{
    mapping (address => uint) public userbalance;
    ...
    function withdraw(uint amount) public{
        if(userbalance[msg.sender] >= amount){
            require(msg.sender.call.value(amount));
            userbalance[msg.sender] -= amount;
        }
    }
}
```

```solidity
contract simpleDAO{
    mapping (address => uint) public userbalance;
    ...
    modifier nonReentrant(){
    	require(_noEntered);
    	_noEntered = false;
    	_;
    	_noEntered = true;
    }
    function withdraw(uint amount) nonReentrant{
        if(userbalance[msg.sender] >= amount){
            require(msg.sender.call.value(amount));
            userbalance[msg.sender] -= amount;
        }
    }
}
```



​       从2016年1.5亿美元的DAO攻击到2022年8000万美元的Fei协议攻击，重入漏洞造成了巨大的经济损失。在本节中，我们将描述 DAO 智能合约的简化版本如何发生重入攻击，如图 1 所示。示例合约是为资产管理而开发的。它使用变量userbalance（第2行）来记录每个用户的余额，并允许用户调用withdraw()函数（第4行）来提取他们的余额。在提现函数中，合约首先检查调用者（由地址变量 msg.sender 表示）是否有足够的余额（第 5 行）；然后，它将请求的以太币数量传输给调用者，并从变量 userbalance 中记录的调用者余额中减去该金额。然而，Solidity 引入了一种特殊的机制，称为“后备函数”。用户可以在后备函数中编写自己的代码，如果合约从其他地址收到以太币，该函数将被执行。在示例中，以太传输函数call.value()（第6行）将自动调用调用者合约的后备函数，从而调用者可以接管控制流。攻击者可以在后备函数中部署恶意代码来重复调用withdraw()函数。请注意，在第二次调用withdraw()时，由于从第6行的call.value()函数开始调用，因此第7行尚未执行，因此此时用户余额尚未发生变化。结果，第二次调用的条件检查（第 5 行）通过，受害者合约将重复将以太币转移给调用者，直到合约余额耗尽。

测试工具误报的常见原因

- 权限控制：基于符号执行的工具通常使用特定的模式检测漏洞。然而，他们在检查控制流路径时没有考虑用户的权限。导致基于权限控制误报的原因有三种：身份控制、地址控制、重入锁。

  > 这里介绍的身份控制就是：带有地址限制的函数修饰器  重入锁也是靠函数修饰器。

- 外部调用后状态不变：

  ![image-20231028203802039](https://raw.githubusercontent.com/m1crofan/image/main/image-20231028203802039.png)

- **没有财务风险的情况下更改状态变量**。一些智能合约可能会在外部调用后改变状态变量，从而使其容易受到重入攻击。然而，并非所有状态变化都会导致重入漏洞。以图7中的函数为例。第 3 行的代码定义了对地址“token”的外部调用，然后第 4 行的代码将其分配给状态变量 token。

